# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
pred <- project(x = i, R = c(1.5,1.5), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence, file = 'simulated.RData')
rm(list=ls())
ls()
dat=rep(1,5)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
pred <- project(x = i, R = c(1.5,1.5), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence, file = 'simulated.RData')
ls()
rm(ls())
rm(c(ls()))
c(ls())
rm(list = ls())
rm(list = as.vector(ls()))
dat=rep(1,5)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
pred <- project(x = i, R = c(1.5,1.5), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence, file = 'simulated.RData')
rm(list = as.vector(ls()))
# library(ebolaproj)
# # load sample data to check
# load(file = 'simulated.RData')
#
# dim(incidence)
dat=rep(1,5)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
pred <- project(x = i, R = c(1.5,1.5), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence, file = 'simulated.RData')
rm(list = as.vector(ls()))
rm(list = as.vector(ls()))
library(ebolaproj)
# load sample data to check
load(file = 'simulated.RData')
dim(incidence)
dim(incidence)
N_geo <- ncol(incidence)-1
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
SI <- SI_gamma_dist_EpiEstim(mu = mean_SI,
cv = CV_SI,
SItrunc = 40)
devtools::load_all(".")
library(ebolaproj)
devtools::load_all(".")
library(ebolaproj)
SI_gamm
getwd()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all('ebolaproj')
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
devtools::document()
library(ebolaproj)
library(incidence)
library(projections)
library(epitrix)
library(EpiEstim)
dat=rep(1,5)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
pred <- project(x = i, R = c(1.5,1.5), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence, file = 'simulated.RData')
rm(list = as.vector(ls()))
devtools::load_all('.')
library(ebolaproj)
# load sample data to check
load(file = 'simulated.RData')
dim(incidence)
rm(list = as.vector(ls()))
devtools::load_all('.')
library(ebolaproj)
load(file = 'simulated.RData')
dim(incidence)
N_geo <- ncol(incidence)-1
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
SI <- SI_gamma_dist_EpiEstim(mu = mean_SI,
cv = CV_SI,
SItrunc = 40)
rep <- 5e3
sigma_prop <- rep(0.1,N_geo*2)         # initial proposal variances (they are now tuned!)
if ( N_geo>1 ){
mu0 <- colMeans(incidence[,-1])*SI$SItrunc
}else{
mu0 <- mean(incidence[,-1])*SI$SItrunc
}
theta0 <- c(rep(1,N_geo), mu0)          # initial parameter R=1 (time # of locations, and initial number of cases in the past)
##########################################################
# test just me testing the MCMC_iter without tuning
res1 <- MCMC_iter(I = incidence,
N_geo = N_geo,
iter = 1e2,
theta0 = theta0,
s = sigma_prop,
SI = SI,
mu0 = mu0)
##########################################################
res0 <- adapt_tuning(repli = 10,
I = incidence,
N_geo = N_geo,
within_iter = rep/10,
theta0 = theta0,
sigma = sigma_prop,
SI = SI,
mu0 = mu0)
Acc <- colSums(diff(res$theta)!=0)/rep          # acceptance rate (should be close to .2)
res0 <- adapt_tuning(repli = 10,
I = incidence,
N_geo = N_geo,
within_iter = rep/10,
theta0 = theta0,
sigma = sigma_prop,
SI = SI,
mu0 = mu0)
print('halfway!')             # message halfway through (effectively, including tuning, we do 2xrep iterations)
res <- MCMC_iter(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0)
rep
Acc <- colSums(diff(res$theta)!=0)/rep          # acceptance rate (should be close to .2)
Acc
# plot traces
plot(res$logL[,1])                                  # of likelihood
layout(matrix(1:N_geo,2,ceiling(N_geo/2),byrow = TRUE))
for (i in 1:N_geo) plot(res$theta[,i])              # of R's
for (i in 1:N_geo) plot(res$theta[,N_geo+i])        # of initial conditions
if (N_geo>1){
apply(res$theta[,1:N_geo],2,quantile,c(.5,.025,.975))   # median and 95%CrI of Rs by locations
}else{
quantile(res$theta[,1],c(.5,.025,.975))
}
save.image('test_on_simulation1.RData')             # saving so far
res <- MCMC_full(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0,
repli = 10,
within_iter = rep/100)
MCMC_full <- function(I,N_geo,iter,theta0,s,SI,mu0,repli_adapt,within_iter){
res0 <- adapt_tuning(repli = repli_adapt,
I = I,
N_geo = N_geo,
within_iter = within_iter,
theta0 = theta0,
sigma = s,
SI = SI,
mu0 = mu0)
# adaptative tuning bit: we run an MCMC with rep/10 iterations, then
# adjust the proposal variance to reach 0.2
# do again using parameter value from the last iteration of the previous MCMC
# repeat 10 times
# from experience, this is enough to tunes proposal variances well, but worth checking
# see below for final acceptance rate output
# see Rscript/MCMC_Rt_2018.R for full function
# print('halfway!')             # message halfway through (effectively, including tuning, we do 2xrep iterations)
res <- MCMC_iter(incidence = I ,
N_geo = N_geo,
iter = iter,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0)
# run the MCMC to sample posterior of R and initial coniditions at each location
# FYI: this is called internally by adapt_tuning
# see Rscript/MCMC_Rt_2018.R for full function
# needs:
# I: the incidence for the time window during which we assume Rt to be constant.
# N_geo: the number of locations
# iter: the number of iteration for the MCMC
# theta0: inital parameters, here taken from the last MCMC iteration after tuning (save some burn-in)
# s: variance of proposal distribution (log-normal)
# SI: the serial interval(use SI_gamma_dist_EpiEstim to define), or need to be a list with vector dist for the daily distribution and SItrunc: an integer for the threshold of serial interval, if SItrunc=40, then dist is 41 element long to include day 0
# mu0: initial conidtions to guaranty that if R=1, then we predict the number of cases in the future will stablise at the mean number of cases observed in the time window
# mu0 is also used as the mean of the (exponential) prior for intial conditions estimated
return(res)
}
res <- MCMC_full(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0,
repli = 10,
within_iter = rep/100)
devtools::load_all(".")
View(MCMC_full)
rm(MCMC_full)
res <- MCMC_full(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0,
repli = 10,
within_iter = rep/100)
devtools::load_all(".")
res <- MCMC_full(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0,
repli = 10,
within_iter = rep/100)
I = incidence
N_geo = N_geo
iter = rep
theta0 = res0$theta0
s = res0$sigma
SI = SI
mu0 = mu0
repli = 10
within_iter = rep/100
res0 <- adapt_tuning(repli = repli_adapt,
I = I,
N_geo = N_geo,
within_iter = within_iter,
theta0 = theta0,
sigma = s,
SI = SI,
mu0 = mu0)
repli_adapt = 10
res0 <- adapt_tuning(repli = repli_adapt,
I = I,
N_geo = N_geo,
within_iter = within_iter,
theta0 = theta0,
sigma = s,
SI = SI,
mu0 = mu0)
devtools::load_all(".")
res <- MCMC_full(I = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0,
repli_adapt = 10,
within_iter = rep/100)
Acc <- colSums(diff(res$theta)!=0)/rep          # acceptance rate (should be close to .2)
Acc
# plot traces
plot(res$logL[,1])                                  # of likelihood
layout(matrix(1:N_geo,2,ceiling(N_geo/2),byrow = TRUE))
for (i in 1:N_geo) plot(res$theta[,i])              # of R's
for (i in 1:N_geo) plot(res$theta[,N_geo+i])        # of initial conditions
if (N_geo>1){
apply(res$theta[,1:N_geo],2,quantile,c(.5,.025,.975))   # median and 95%CrI of Rs by locations
}else{
quantile(res$theta[,1],c(.5,.025,.975))
}
save.image('test_on_simulation1.RData')             # saving so far
# forward projection
Nsim <- 1e3                                           # number of simulation to get median and 95%CrI predictions
I_pred <- Sim_Pois(Results = res ,
Nsim = Nsim,
week_forward = 4+4,
N_geo = N_geo,
SI = SI)
# forward projection
Nsim <- 1e3                                           # number of simulation to get median and 95%CrI predictions
I_pred <- Proj_Pois(Results = res ,
Nsim = Nsim,
week_forward = 4+4,
N_geo = N_geo,
SI = SI)
# function to project forward, see Rscript/useful_functions.R
# needs the parameters estimated (Results)
# number of simulations
# week_forward: number of week projected from the START of the time window, SO: includes the period of time
# for which we have data!!! e.g. if we have 2 weeks of data and want to project for the 4 weeks
# after that, week_forward should be 6.
# require number of locations + serial interval
# forward projection
Nsim <- 1e3                                           # number of simulation to get median and 95%CrI predictions
I_pred <- Proj_Pois(Results = res ,
Nsim = Nsim,
week_forward = 4+4,
N_geo = N_geo,
SI = SI)
# function to project forward, see Rscript/useful_functions.R
# needs the parameters estimated (Results)
# number of simulations
# week_forward: number of week projected from the START of the time window, SO: includes the period of time
# for which we have data!!! e.g. if we have 2 weeks of data and want to project for the 4 weeks
# after that, week_forward should be 6.
# require number of locations + serial interval
devtools::load_all(".")
I_pred <- Proj_Pois(Results = res ,
Nsim = Nsim,
week_forward = 4+4,
N_geo = N_geo,
SI = SI)
# plot the observed incidence in the time window of interest and the median and 95%CrI predictions
layout(matrix(1:N_geo,2,ceiling(N_geo/2),byrow = TRUE))
for(i in 1:N_geo){
CI_pred <- apply(I_pred[,i,101:dim(I_pred)[3]],2,quantile,c(.5,.025,.975))
plot(1:nrow(incidence),incidence[,1+i],
xlim=c(0,ncol(CI_pred)),
ylim = c(0,1+max(c(incidence[,1+i],as.vector(CI_pred)))) )
x <- 1:ncol(CI_pred)
lines(x,CI_pred[1,],col='blue',lwd=2)
polygon(c(x,rev(x)), c(CI_pred[2,],rev(CI_pred[3,])),
col = rgb(0,0,1,.2), border = FALSE )
}
# plot the observed incidence in the time window of interest and the median and 95%CrI predictions
layout(matrix(1:N_geo,2,ceiling(N_geo/2),byrow = TRUE))
for(i in 1:N_geo){
CI_pred <- apply(I_pred[,i,101:dim(I_pred)[3]],2,quantile,c(.5,.025,.975))
plot(1:nrow(incidence),incidence[,1+i],
xlim=c(0,ncol(CI_pred)),
ylim = c(0,1+max(c(incidence[,1+i],as.vector(CI_pred)))),
xlab = 'time', ylab = 'incidence')
x <- 1:ncol(CI_pred)
lines(x,CI_pred[1,],col='blue',lwd=2)
polygon(c(x,rev(x)), c(CI_pred[2,],rev(CI_pred[3,])),
col = rgb(0,0,1,.2), border = FALSE )
}
R
R <- 1.5
if (N_geo>1){
R_est <- apply(res$theta[,1:N_geo],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of Rs by locations
I0_est <- apply(res$theta[,(N_geo_1):(2*N_geo)],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of I0
}else{
R_est <- quantile(res$theta[,1],c(.5,.025,.975))
I0_est <- quantile(res$theta[,2],c(.5,.025,.975))
}
if (N_geo>1){
R_est <- apply(res$theta[,1:N_geo],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of Rs by locations
I0_est <- apply(res$theta[,(N_geo+1):(2*N_geo)],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of I0
}else{
R_est <- quantile(res$theta[,1],c(.5,.025,.975))
I0_est <- quantile(res$theta[,2],c(.5,.025,.975))
}
I0
I0 <- 5
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,])
library(Hmisc)
layout(matrix(1:2,1,2,byrow = TRUE))
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,])
lines(c(1,N_geo),rep(R,2), color = 'red')
errbar(1:N_geo,I0_est[1,],I0_est[2,],I0_est[3,])
lines(c(1,N_geo),rep(R,2), color = 'red')
layout(matrix(1:2,2,1,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,])
lines(c(1,N_geo),rep(R,2), col = 'red')
errbar(1:N_geo,I0_est[1,],I0_est[2,],I0_est[3,])
lines(c(1,N_geo),rep(R,2), col = 'red')
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,])
lines(c(1,N_geo),rep(R,2), col = 'red')
errbar(1:N_geo,I0_est[1,],I0_est[2,],I0_est[3,])
lines(c(1,N_geo),rep(R,2), col = 'red')
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,],
xlab = 'location', ylab = 'R')
lines(c(1,N_geo),rep(R,2), col = 'red')
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,],
xlab = 'location', ylab = 'R',ylim = c(0,3))
lines(c(1,N_geo),rep(R,2), col = 'red')
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,],
xlab = 'location', ylab = 'R',ylim = c(0,3), bty = 'n')
lines(c(1,N_geo),rep(R,2), col = 'red')
library(ebolaproj)
getwd()
devtools::document()
devtools::document()
library(ebolaproj)
library(ebolaproj)
devtools::document()
library(ebolaproj)
devtools::document()
library(ebolaproj)
library(ebolaproj)
SI_gamma_dist_EpiEstim(2,3,5)
