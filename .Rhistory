I<-incidence[,-1]
a=I[,1]
a
matrix(a,3,lebgth(a))
matrix(a,3,length(a))
matrix(a,3,length(a),byrow = TRUE)
library(incidence)
library(projections)
library(devtools)
install_github('reconhub/projections')
library(incidence)
library(projections)
library(epitrix)
library(EpiEstim)
install_github('annecori/EpiEstim')
library(incidence)
install_github('reconhub/incidence')
library(incidence)
install_github('reconhub/incidence')
install_github('reconhub/incidence',force=TRUE)
library(incidence)
library(incidence)
install.packages("incidence")
library(incidence)
library(projections)
library(epitrix)
library(EpiEstim)
library(EpiEstim)
library(Hmisc)
library(ebolaproj)
I0 <- 5
dat=rep(1,I0)
i <- incidence::incidence(dat)  # 20 cases to start with
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
SItrunc <- 40
SI_Distr <- sapply(0:SItrunc, function(e) EpiEstim::DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
SI_Distr
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50,model = "poisson" )
R <- 1.5
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50,model = "poisson" )
R <- 1.5
over_d <- 0.03
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50,model = "poisson" , size = over_d)
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(pred,4*7))
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50,model = "poisson" , size = over_d)
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
i
SI_Distr
projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
rm(pred)
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
pred
tail(pred,4*7)
temp <- as.matrix(rped)
temp <- as.matrix(pred)
View(temp)
tail(temp,4*7)
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(temp,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
f
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "negbin" , size = over_d)
temp <- as.matrix(pred)
View(temp)
dat
I0 <- 5
dat=rep(1,I0)
dat
I0 <- 5
dat=rep(1,I0)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence::incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) EpiEstim::DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
R <- 1.5
over_d <- 0.03
# pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
#                 si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 50, model = "negbin" , size = over_d)
temp <- as.matrix(pred)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(temp,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
I0 <- 5
dat=rep(1,I0)
## simulate basic epicurvedat <- c(0, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 6)
i <- incidence::incidence(dat)  # 20 cases to start with
# plot(i)
# SI
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
# params <- gamma_mucv2shapescale(mean_SI, CV_SI)
# si <- distcrete("gamma", interval = 1L,
#                   shape = params$shape,
#                   scale = params$scale, w = 0.5)
# si$d(0:30) # problem of first one
SItrunc <- 40
# serial distribution
SI_Distr <- sapply(0:SItrunc, function(e) EpiEstim::DiscrSI(e,mean_SI,mean_SI*CV_SI) )
SI_Distr <- SI_Distr / sum(SI_Distr)
#simulate 40 days
R <- 1.5
over_d <- 0.03
# pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
#                 si = SI_Distr, n_days = 150, n_sim = 50, model = "poisson" )
pred <- projections::project(x = i, R = rep(R,2), R_fix_within = TRUE,
si = SI_Distr, n_days = 150, n_sim = 1e2, model = "negbin" , size = over_d)
temp <- as.matrix(pred)
# keep incidence of last 20 days
incidence <- data.frame(date = as.Date('01/05/2018',format='%d/%m/%Y')+seq(0,4*7-1),
I = tail(temp,4*7))
f <- which(colSums(incidence[,-1])==0) # remove location with 0 cases in last 20 days
if (length(f)>0) incidence <- incidence[,-(f+1)]
incidence <- incidence[,1:11]
# I_cum_hist <- colSums(head(pred,150-20))
save(incidence,R, file = 'simulated_nb.RData')
N_geo <- ncol(incidence)-1
mean_SI <- 14.2
CV_SI <- 9.6/14.2 # from http://www.nejm.org/doi/suppl/10.1056/NEJMc1414992/suppl_file/nejmc1414992_
SI <- SI_gamma_dist_EpiEstim(mu = mean_SI,
cv = CV_SI,
SItrunc = 40)
#' SerialInterval
#'
#' This is an example of how to create and document exported functions.
#'
#' @param input you should always document the paramters.
#'              Including the expected data type.
#'
#' @export
#'
# SI
SI_gamma_dist_EpiEstim <- function(mu,cv,SItrunc){
SI_Distr <- sapply(0:SItrunc, function(e) EpiEstim::DiscrSI(e,mu,mu*cv) )
SI_Distr <- SI_Distr / sum(SI_Distr)
return(list(dist = SI_Distr, SItrunc = SItrunc))
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
SI <- SI_gamma_dist_EpiEstim(mu = mean_SI,
cv = CV_SI,
SItrunc = 40)
rep <- 2e2
sigma_prop <- rep(0.1,N_geo*2)         # initial proposal variances (they are now tuned!)
if ( N_geo>1 ){
mu0 <- colMeans(incidence[,-1])*SI$SItrunc
}else{
mu0 <- mean(incidence[,-1])*SI$SItrunc
}
theta0 <- c(rep(1,N_geo), mu0)          # initial parameter R=1 (time # of locations, and initial number of cases in the past)
#' get likelihood
#'
#' get Poisson likelihood
#' internal to the MCMC
#'
#' @param lambda: 'force of infection' matrix (incidence weighted by serial interval),
#'                  column number of days, row: number of locations
#'
#' @param I matrix of observed incidence, same dimension as lambda
#'
#' @param R0 vector of reproduction numbers per locations
#'
#' @details  L log likelihood
#' @export
#'
Like1<-function(lambda,I,R0){
R <- R0%*%matrix(1,1,ncol(I))
L <- sum(rowSums(-R*lambda+I*log(R*lambda),na.rm=TRUE),na.rm=TRUE) # poisson likelihood (or bits we are interested in!)
return(L)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
#' MCMC iterate
#'
#' run the MCMC to sample posterior of R and initial coniditions at each location
#' FYI: this is called internally by adapt_tuning
#'
#' @param incidence the incidence for the time window during which we assume Rt to be constant.
#'           I is a dataframe, first column are dates then incidence for all locations
#'           nb of row is the size of time widows, dates must be sequential
#'
#' @param N_geo integer of  numbers of locations
#'
#' @param iter integer, the number of iteration for the MCMC
#'
#' @param theta0 vector of inital parameters, here taken from the last MCMC iteration after tuning (save some burn-in)
#'
#' @param s variance of proposal distributions (log-normal) - tuned previously
#'
#' @param SI Serial interval distribution (see SI_gamma_dist_EpiEstim)
#'
#' @param mu0: initial conidtions to guaranty that if R=1, then we predict the number of cases in the future will stablise at the mean number of cases observed in the time window
#'              mu0 is also used as the mean of the (exponential) prior for intial conditions estimated
#'
#' @details  res a list containing 2 matrices: theta: matrix of posterior samples
#'                      and logL: matrix of associated log-likelihood
#' @export
#'
MCMC_iter <- function(incidence,N_geo,iter,theta0,s,SI,mu0,over_disp = NA){
I <- incidence[,-1]     # remove dates (everything needs to be consecutive days)
#############################################################################
# for MCMC
thetas <- matrix(NA,iter,N_geo*2)  # Rt's and initial conditions for each location
L <- thetas                         # store likelihoods
#############################################################################
# get the daily 'forces of infections'
lambda <- lambda_fct(param = theta0 , I = t(I), N_l = N_geo ,
ws = rev(SI$dist) , SItrunc = SI$SItrunc)
if (is.na(over_disp)){
L1 <- Like1(lambda,t(I),theta0[1:N_geo])
}else{
L1 <- LikeNb(lambda,t(I),theta0[1:N_geo],over_disp = over_disp)
}
L[1,] <- L1
thetas[1,] <- theta0
#############################################################################
# sampling
for (i in 2:iter){
#print(i)
for (j in 1:(2*N_geo)){
Ts <- theta0
lambdaT <- lambda
# propose new parameter j
Ts[j] <- Ts[j]*exp(s[j]*rnorm(1,0,1))
# get the new 'force of infection'
lambdaT <- lambda_fct(param = Ts , I = t(I), N_l = N_geo ,
ws = rev(SI$dist) , SItrunc = SI$SItrunc)
# get the likelihood for proposae value
Lint <- Like1(lambdaT,t(I),Ts[1:N_geo])
if (is.na(over_disp)){
Lint <- Like1(lambdaT,t(I),Ts[1:N_geo])
}else{
Lint <- LikeNb(lambdaT,t(I),Ts[1:N_geo],over_disp = over_disp)
}
#get the ratio with previous value of parameter and correct for porposal (and, only for initial conditions, prior distribution)
if (j <= N_geo){
r <- exp(Lint-L1)*Ts[j]/theta0[j]
}else{
r <- exp(Lint-L1)*Ts[j]/theta0[j]*exp(1/mu0[j-N_geo]*(theta0[j]-Ts[j])) # with weak exponential prior
}
# accept or reject
if (runif(1,0,1) <= r){
theta0[j] <- Ts[j]  # if accept, keep new parameter value
lambda <- lambdaT   # if accept, keep new force of infection
L1 <- Lint          # if accept, keep new lieklihood
}
L[i,j] <- L1    # store final likelihood
}
thetas[i,] <- theta0  # store final parameter values for this iteration
}
####
res <- list(theta = thetas, logL = L)
return(res)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
#' 'force of infection'
#'
#' return incidence weighted by serial interval for the time window of interest
#' internal to the MCMC
#'
#' @param param: 'force of infection' matrix (incidence weighted by serial interval),
#'                  column number of days, row: number of locations
#'
#' @param I matrix of observed incidence, same dimension as lambda
#'
#' @param N_l integer of  numbers of locations
#'
#' @param ws vector reversed serial interval distribution (output from SI_gamma_dist_EpiEstim reverse in the MCMC function) )
#'
#' @param SItrunc integer, threshold of serial interval distribution (see SI_gamma_dist_EpiEstim)
#'
#'
#' @details lambda incidence weighted by serial interval
#' @export
#'
lambda_fct<-function(param, I, N_l, ws, SItrunc){
# reconstruct expected daily cases in the past
I0 <- matrix(0,N_l,100)
I0[,1] <- param[(N_l+1):(2*N_l)]
for (i in 2:100){
f <- max(c(1,(i-SItrunc)))
I0[,i] <- param[1:N_l]*(I0[,f:i]%*%ws[((SItrunc+1)-(i-f)):(SItrunc+1)])
}
I_full <- cbind(I0,I)
# predict future incidence weighted by serial interval for the time window (this multiplied by R give mean expected number of cases)
lambda <- matrix(NA,N_l,ncol(I))
for (i in 101:ncol(I_full)){
lambda[,i-100] <- I_full[,(i-SItrunc):i]%*%ws
}
return(lambda)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
res1 <- MCMC_iter(incidence = incidence,
N_geo = N_geo,
iter = 1e2,
theta0 = theta0,
s = sigma_prop,
SI = SI,
mu0 = mu0,over_disp = over_d)
#' get likelihood
#'
#' get NegBin likelihood
#' internal to the MCMC
#'
#' @param lambda: 'force of infection' matrix (incidence weighted by serial interval),
#'                  column number of days, row: number of locations
#'
#' @param I matrix of observed incidence, same dimension as lambda
#'
#' @param R0 vector of reproduction numbers per locations
#'
#' @details  L log likelihood
#' @export
#'
LikeNb<-function(lambda,I,R0,over_disp){
R <- R0%*%matrix(1,1,ncol(I))
# L <- sum(rowSums(-R*lambda+I*log(R*lambda),na.rm=TRUE),na.rm=TRUE) # poisson likelihood (or bits we are interested in!)
L <- sum(dnbinom(x = I, size = over_disp, mu = R*lambda, log = TRUE) , na.rm = TRUE)
return(L)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
res1 <- MCMC_iter(incidence = incidence,
N_geo = N_geo,
iter = 1e2,
theta0 = theta0,
s = sigma_prop,
SI = SI,
mu0 = mu0,over_disp = over_d)
res0 <- adapt_tuning(repli = 10,
I = incidence,
N_geo = N_geo,
within_iter = rep/10,
theta0 = theta0,
sigma = sigma_prop,
SI = SI,
mu0 = mu0, over_disp = over_d)
#' adaptative tuning
#'
#' tune proposal and give good initial values to start 'proper' MCMC
#'  try to tune variance toward 20% acceptance
#'
#' @param repli number of time the variance of the proposal is tuned (10 tends to be ok)
#'
#' @param within_iter iterations for evaluate the accpetance with new proposal variances
#'
#' @param sigma original variance to start with
#'
#' @param others same as in MCMC_iter function
#'
#'
#' @details res list of 2 vectors: theta0: posterior samples at the last iterations
#'                       sigma: new variance for the proposal distribution
#' @export
#'
## adaptative tuning
# tune proposal and give good initial values to start 'proper' MCMC
# repli: number of time the variance of the proposal is tuned (10 tend to be ok)
# within_iter: iteration for evaluate the accpetance with new proposal variances
# sigma: original variance to start with
# others: as in MCMC_iter
adapt_tuning <- function(repli,I,N_geo,within_iter,theta0,sigma,SI,mu0,over_disp = NA){
new_sigma <- sigma
for (i in 1:repli){
# run MCMC with wthin_iter iterations
res <- MCMC_iter(incidence = I ,
N_geo = N_geo,
iter = within_iter,
theta0 = theta0,
s = new_sigma,
SI = SI,
mu0 = mu0,
over_disp = over_disp)
# colSums(diff(res$theta)!=0)/(within_iter-1)
# tune the variance according to accpetance
new_sigma <- adapt(theta = res$theta,
s = new_sigma,
it = within_iter)
# new starting value for the parameters for the next round of MCMC
theta0 <- res$theta[within_iter,]
# plot(res$theta[,2],ylim=c(0,50))
}
res <- list(theta0 = theta0,
sigma = new_sigma)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
#' tuning
#'
#' tune variance proposal
#'  try to tune variance toward 20% acceptance
#'
#' @param theta matrix, samples of posterior distribution. ncol: nb parameters, nrow: nb samples
#'
#' @param s vector, proposal variances used to obtain posterior samples theta
#'
#' @param it integer, nro of theta
#'
#'
#' @details lambda incidence weighted by serial interval
#' @export
adapt <- function(theta,s,it){
Acc <- colSums(diff(theta)!=0)/(it-1)   # current acceptance rate
s_out <- Acc/.2*s                       # reduce variance if accptance was too low, or increase variance if accpetance was too high (work well!)
s_out[which(Acc==0)] <- s[which(Acc==0)]/2   # if never accpeted half the variance of the proposal
return(s_out)
}
#' You can also document internal package function with roxygen
#'
#' Just make sure you add 'noRd' so no latex help files are being created.
#' @noRd
some_internal_function <- function() {
NA
}
res0 <- adapt_tuning(repli = 10,
I = incidence,
N_geo = N_geo,
within_iter = rep/10,
theta0 = theta0,
sigma = sigma_prop,
SI = SI,
mu0 = mu0, over_disp = over_d)
res <- MCMC_iter(incidence = incidence,
N_geo = N_geo,
iter = rep,
theta0 = res0$theta0,
s = res0$sigma,
SI = SI,
mu0 = mu0)
Acc <- colSums(diff(res$theta)!=0)/rep          # acceptance rate (should be close to .2)
Acc
plot(res$logL[,1])                                  # of likelihood
layout(matrix(1:N_geo,2,ceiling(N_geo/2),byrow = TRUE))
for (i in 1:N_geo) plot(res$theta[,i])              # of R's
for (i in 1:N_geo) plot(res$theta[,N_geo+i])        # of initial conditions
if (N_geo>1){
R_est <- apply(res$theta[,1:N_geo],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of Rs by locations
I0_est <- apply(res$theta[,(N_geo+1):(2*N_geo)],2,
quantile,c(.5,.025,.975))   # median and 95%CrI of I0
}else{
R_est <- quantile(res$theta[,1],c(.5,.025,.975))
I0_est <- quantile(res$theta[,2],c(.5,.025,.975))
}
R_est
layout(matrix(1:2,1,2,byrow = TRUE))
errbar(1:N_geo,R_est[1,],R_est[2,],R_est[3,],
xlab = 'location', ylab = 'R',ylim = c(0,3), bty = 'n')
lines(c(1,N_geo),rep(R,2), col = 'red')
